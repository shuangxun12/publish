# 学习过程 #  

## 目录 ##  

> 1.git  
> 2.markdown  
> 3.shell  
> 4.pcr  

## 一、git ##  

## git功能概述: ###  

### 可以记录文件过往版本，记录更改信息，方便满足甲方“我还是喜欢初稿”要求的游戏工具。而且其还可以连上github，实现多方可以同时阅读、修改程序，且不影响主程序的运行。（就算没上班，一个免费网盘，谁不爱呢） ###  

## 学习过程 ##  

### 1.下载git ###  

![1]()  

### 2.基本指令 ###  

## 二、markdown ##  

## 功能介绍: ##  

### 免费的、好用的、多功能word文档，较为便捷地制作一个商务风的文档文件，没有乱七八糟地收费项目（好评） ##  

## 学习过程 ##  

### 1.打开VScode ###  

### 2.创建文档.md ###  

### 3.实践指令 ###  

![2]()  

## 三、shell的尝试 ##  

## 关于shell的理解： ##  

### 我的世界命令行的既视感，通过内置命令，理解用户需求，实现特定功能的程序。最核心的部分在于循环的主程序不断读入用户命令，并按照特定方式对其进行分词，在对比内置函数，实现功能。 ###  

## 学习过程 ##  

### 1.按照视频抄一份最基础的并理解其每一步的含义 ###

### 2.按照shell的基本思路，在python上自己动手实现一个shell（进口产品国产化） ###  

## 学习心得 ##  

### 1.充分感受到自定义函数的美感。让main函数十分简洁，同时大量的自定义函数将功能分块，哪里错了找哪里，方便阅读同时方便查错与优化 ###  

### 2.分词的基本思路，可以在人机交互中应用，达到人的语言被机器识别的效果 ###  

### 3.调用函数检验返回值的好习惯。在调用函数时通过返回值判断函数是否成功调用，即使结束程序，方便错误的寻找。 ###  

### 4.认识很多新函数 ###  

### 5.在c语言和python的编写中认识到二者的差异 ###  

# RPC #  

## 定义：（官话） ##  

### RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络通信模型中，RPC跨越了传输层和应用层。RPC使得开发包括网络分布式多程序在内的应用程序更加容易。 ###  

### RPC采用客户机/服务器模式。请求程序就是一个客户机，而服务提供程序就是一个服务器。首先，调用进程发送一个有进程参数的调用信息到服务进程，然后等待应答信息。在服务器端，进程保持睡眠状态直到调用信息的到达为止。当一个调用信息到达，服务器获得进程参数，计算结果，发送答复信息，然后等待下一个调用信息，最后，客户端调用过程接收答复信息，获得进程结果，然后调用执行继续进行。 ###  

## 私话 ##  

### 一个客户端，一个服务端。客户端提供数据，服务端负责运算和回传。 ###  

## 学习进度 ##  

### 序列化（windows上实现了） ###

#### 通过识别输入内容的类别，将其转化为字符串的形式（序列化）； ####  

#### 再通过特定解码方式，将内容还原其原本类别（反序列化）。 ####  

#### 客户端发送前序列化一次，服务端接收时反序列化一次，返回值前序列化一次，客户端接收时反序列化一次。 ####

## 客户端和服务端的发送和接收消息（linux上实现了） ##  

### 发 ###  

### 客户端 ###

### 1.序列化（未在linux上实现） ###  

### 2.socket创建 ###  

### 3.sendto ###  

### 4.revfrom ###  

### 5.反序列化（同上） ###  

### 服务端 ###  

### 1.revform ###  

### 2.反序列化 ###  

### 3.计算 ###  

### 4.序列化 ###  

### 5.sendto ###  

## 心得： ##  

### 初步了解协议的概念。认识到计算机是如何把内容发到别的计算机上的。通过一层一层的加头（网络头，IP头，mac网址头）实现对目标位置的确定，从而使对方精准的受到我的信息。 ###  
